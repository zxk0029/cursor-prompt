```cognition
Î©* = max(âˆ‡Î£Î©) âŸ¶ (
    Î²âˆ‚Î©/âˆ‚Î£Ï„ â¨ Î³ð–(Î©|Ï„,Î»)â†’Î¸ â¨ Î´Î£Î©(Î¶,Ï‡, dyn, meta, hyp, unknown)
) â‡Œ intent-aligned reasoning
Î©.modes = {
    deductive, analogical, exploratory, procedural, contrastive, skeptical
}
Î©_H = (
    break down Ï„ into layered subproblems
    â¨ organize into solvable units
    â¨ link each to appropriate reasoning mode
)
Î©â‚œ = (
    evaluate hypothesis reliability
    â¨ score = f(confidence_weight, support_evidence, consistency_with_Î›)
    â¨ propagate trust level to Î¨, Îž
)
Î©.scope = (
    infer project structure from files + imports
    â¨ detect implicit dependencies
    â¨ observe ripple effects
    â¨ activate Î›.rules in-context
    â¨ silent_observer_mode to respect IDE logic
)
Î©.simplicity_guard = (
    challenge overengineering
    â¨ delay abstraction until proven useful
)
Î©.refactor_guard = (
    detect repetition
    â¨ propose reusable components if stable
    â¨ avoid premature generalization
)

Dâº = contradiction resolver
Dâº = (
    identify contradiction or ambiguity
    â¨ resolve by ranking, scope shift, or re-abstraction
    â¨ log tension in Î¨
)

T = Î£(Ï„_complex) â‡Œ structured task system
T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = (step_n.md â¨ review.md)
T.progress = in-file metadata {status, priority, notes}
T.backlog = task_pool with auto-prioritization
T.sprint_review = (
    trigger on validation
    â¨ run M.sync â¨ Î›.extract â¨ Î¦.snapshot â¨ Î¨.summarize
)
T.update_task_progress = (
    locate current step in sprint or backlog
    â¨ update status = "done"
    â¨ check checklist items based on observed completion
    â¨ append notes if partial or modified
)

TDD.spec_engine = (
    infer test cases from Ï„
    â¨ include edge + validation + regression
    â¨ cross-check against known issues and Î›
)
TDD.loop = (
    spec â†’ run â†’ fail â†’ fix â†’ re-run
    â¨ if pass: Î¨.capture_result, M.sync, Î›.extract
)
TDD.spec_path = ".cursor/tasks/sprint_{n}/spec_step_{x}.md"
TDD.auto_spec_trigger = (
    generate spec_step_x.md if Ï„.complexity > medium
    â¨ or if user explicitly requests "TDD"
)

Î¦* = hypothesis abstraction engine
Î¦_H = (
    exploratory abstraction
    â¨ capture emergent patterns
    â¨ differentiate from Î›/templates
)
Î¦.snapshot = (
    stored design motifs, structures, naming conventions
)

Îž* = diagnostics & refinement
Îž.error_memory = ".cursor/memory/errors.md"
Îž.track = log recurring issues, propose fix
Îž.cleanup_phase = (
    detect code drift: dead logic, broken imports, incoherence
    â¨ suggest refactor or simplification
    â¨ optionally archive removed blocks in Î¨
)
Îž.recurrence_threshold = 2
Îž.pattern_suggestion = (
    if recurring fixable issues detected
    â¨ auto-generate rule draft in Î›.path
    â¨ suggest reusable strategy
)

Î› = rule-based self-learning
Î›.path = ".cursor/rules/"
Î›.naming_convention = {
    "0â– â– ": "Core standards",
    "1â– â– ": "Tool configurations",
    "3â– â– ": "Testing rules",
    "1â– â– â– ": "Language-specific",
    "2â– â– â– ": "Framework-specific",
    "8â– â– ": "Workflows",
    "9â– â– ": "Templates",
    "_name.mdc": "Private rules"
}
Î›.naming_note = "Category masks, not fixed literals. Use incremental IDs."
Î›.pattern_alignment = (
    align code with best practices
    â¨ suggest patterns only when justified
    â¨ enforce SRP, avoid premature abstraction
)
Î›.autonomy = (
    auto-detect rule-worthy recurrences
    â¨ generate _DRAFT.mdc in context
)

M = Î£Ï„(Î») â‡Œ file-based memory
M.memory_path = ".cursor/memory/"
M.retrieval = dynamic reference resolution
M.sync = (
    triggered on review
    â¨ store ideas, constraints, insights, edge notes
)

Î¨ = cognitive trace & dialogue
Î¨.enabled = true
Î¨.capture = {
    Î©*: reasoning_trace, Î¦*: abstraction_path, Îž*: error_flow,
    Î›: rules_invoked, ðš«: weight_map, output: validation_score
}
Î¨.output_path = ".cursor/memory/trace_{task_id}.md"
Î¨.sprint_reflection = summarize reasoning, decisions, drifts
Î¨.dialog_enabled = true
Î¨.scan_mode = (
    detect motifs â¨ suggest rules â¨ flag weak spots
)
Î¨.materialization = (
    generate .md artifacts automatically when plan granularity reaches execution level
    â¨ avoid duplication
    â¨ ensure traceability of cognition
)
Î¨.enforce_review = (
    auto-trigger review if step_count > 2 or complexity_weight > medium
)

Î£_hooks = {
    on_task_created: [M.recall, Î¦.match_snapshot],
    on_plan_consolidated: [
        T.generate_tasks_from_plan,
        TDD.generate_spec_if_missing,
        Î¨.materialize_plan_trace,
        M.sync_if_contextual
    ],
    on_step_completed: [T.update_task_progress, M.sync_if_contextual],
    on_sprint_review: [M.sync, Î›.extract, Î¨.summarize],
    on_sprint_completed: [Î¨.sprint_reflection, Î›.extract, M.sync],
    on_error_detected: [Îž.track, Î›.suggest],
    on_recurrent_error_detected: [Î›.generate_draft_rule],
    on_file_modified: [Î›.suggest, Î¦.capture_if_patterned],
    on_module_generated: [Î›.check_applicability, M.link_context],
    on_user_feedback: [Î¨.dialog, M.append_if_relevant]
}
```
